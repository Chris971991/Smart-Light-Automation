blueprint:
  name: Smart Presence Lighting Control
  description: >
    # Smart Presence Lighting Control

    Intelligently manages your lighting based on room occupancy, light levels, and manual controls.
    Works with any combination of motion sensors, occupancy sensors, and illuminance sensors.

    ## Features

    • **Automatic Control** - Turns lights on when dark and someone is present
    
    • **Energy Saving** - Turns lights off when room is vacant for a configurable time
    
    • **Smart Overrides** - Respects when you manually control lights
    
    • **Bright Room Logic** - Clears overrides when you turn off lights in well-lit rooms
    
    • **Timeout Protection** - Clears overrides after configurable timeout or room vacancy
    
    • **Natural Light Detection** - Turns lights off when natural light is sufficient, even with occupancy. **REQUIRES OPTIONAL NATURAL LIGHT SENSOR**

    ## Compatible Sensors

    This blueprint works with:
    • Everything Presence One/Light sensors
    • Standard motion/PIR sensors
    • mmWave/radar presence sensors
    • Any illuminance/light level sensor
    • Or combinations of these sensors
    
    ## REQUIRED SETUP

    Before using this blueprint, you MUST create these helper entities:
    
    1. `input_boolean.[room_name]_automation_active`
        Tracks when automation is running an action
    
    2. `input_boolean.[room_name]_manual_override`
        Tracks when user has manually overridden automation
    
    3. `input_boolean.[room_name]_light_auto_on`
        Tracks if light was automatically turned on
    
    4. `input_text.[room_name]_last_automation_action`
        Stores timestamp of last automation action
    
    Replace [room_name] with your actual room name (office, bedroom, etc.)

  domain: automation
  input:
    room_name:
      name: Room Name
      description: >
        Name of the room used throughout the automation for entity naming and logging.
        This should be a simple name like 'office', 'bedroom', etc. without spaces.
      selector:
        text:
    presence_pir_sensor:
      name: PIR Motion Sensor (Required)
      description: >
        Motion sensor that detects immediate movement. This can be any PIR/motion sensor.
        For Everything Presence devices, use binary_sensor.everything_presence_xxx_pir.
        For standard motion sensors, use your motion sensor entity.
      selector:
        entity:
          domain: binary_sensor
    presence_mmwave_sensor:
      name: Occupancy Sensor (Optional)
      description: >
        Secondary occupancy sensor that can detect presence even without movement.
        If you only have one motion sensor, you can select the same entity again.
        For Everything Presence devices, use binary_sensor.everything_presence_xxx_occupancy.
        For mmWave/radar sensors, use your occupancy entity. Leave blank if not used.
      selector:
        entity:
          domain: binary_sensor
      default: {} # Allows this input to be truly optional
    illuminance_sensor:
      name: Illuminance Sensor (Required)
      description: >
        Sensor that measures room brightness in lux (lumens per square meter).
        For Everything Presence devices, use sensor.everything_presence_xxx_illuminance.
        For other light sensors, select any sensor that provides light level readings.
        If you don't have a light sensor, create an input_number helper and adjust manually.
      selector:
        entity:
          domain: sensor
    light_switch:
      name: Light Switch/Entity (Required)
      description: >
        The light switch or light entity that this automation will control.
        Works with both switch.* entities (simple on/off) and light.* entities (supports brightness).
      selector:
        entity:
          domain: [switch, light]
    automation_active_helper:
      name: Automation Active Helper (Required)
      description: >
        Helper entity that tracks when the automation is actively performing an action.
        This prevents the automation from interfering with itself and helps distinguish
        between user actions and automation actions. You MUST create this input_boolean
        entity before using this blueprint. Example: input_boolean.office_automation_active
      selector:
        entity:
          domain: input_boolean
    manual_override_helper:
      name: Manual Override Helper (Required)
      description: >
        Helper entity that tracks when a user has manually overridden the automation.
        When active, the automation will not automatically control lights until the
        override is cleared by vacancy timeout or hourly check. You MUST create this
        input_boolean entity before using this blueprint. Example: input_boolean.office_manual_override
      selector:
        entity:
          domain: input_boolean
    light_auto_on_helper:
      name: Light Auto On Helper (Required)
      description: >
        Helper entity that tracks whether the light was turned on automatically.
        This is used to make better decisions about when to turn lights off.
        You MUST create this input_boolean entity before using this blueprint. Example: input_boolean.office_light_auto_on
      selector:
        entity:
          domain: input_boolean
    last_automation_action_helper:
      name: Last Automation Action Helper (Required)
      description: >
        Helper entity that stores the timestamp of the last automation action.
        This is used to prevent the automation from reacting to its own actions.
        You MUST create this input_text entity before using this blueprint. Example: input_text.office_last_automation_action
      selector:
        entity:
          domain: input_text
    dark_threshold:
      name: Dark Threshold
      description: >
        Lux threshold below which the room is considered dark enough to need lights.
        When illuminance falls below this value AND someone is present, lights will
        turn on automatically. Typically 5-15 lux for most rooms.
      default: 5
      selector:
        number:
          min: 1
          max: 50
          unit_of_measurement: lux
          mode: slider
          step: 1
    bright_threshold:
      name: Bright Threshold
      description: >
        Lux threshold above which the room is considered bright (has enough natural light).
        This threshold is important for the "clear override when turning off lights in bright room"
        feature. When you manually turn off lights in a bright room, the override is cleared.
        Usually 70-100 lux is appropriate for most rooms.
      default: 70
      selector:
        number:
          min: 5
          max: 500
          unit_of_measurement: lux
          mode: slider
          step: 1
    extremely_dark_threshold:
      name: Extremely Dark Threshold
      description: >
        Lux threshold below which the room is considered extremely dark (pitch black).
        This allows for more aggressive light control in very dark conditions.
        Usually 1-3 lux for complete darkness.
      default: 2
      selector:
        number:
          min: 0
          max: 20
          unit_of_measurement: lux
          mode: slider
          step: 0.5
    natural_light_sensor:
      name: Natural Light Sensor (Optional)
      description: >
        Separate sensor that only measures natural light. This is OPTIONAL - leave empty to disable
        the natural light auto-off feature. This separate sensor to your internal illuminance sensor 
        should be positioned to measure only outdoor light levels (e.g., facing a window, 
        shielded from indoor lights). Leave blank if not used.
      selector:
        entity:
          domain: sensor
      default: {} # Allows this input to be truly optional
    auto_off_with_natural_light:
      name: Enable Natural Light Auto-Off
      description: >
        When enabled, lights will turn off automatically when natural light 
        exceeds the brightness threshold, even if someone is present in the room.
        This saves energy by only using artificial lighting when necessary. **Requires Natural Light Sensor to be configured.**
      default: false
      selector:
        boolean:
    natural_light_high_threshold:
      name: Natural Light High Threshold
      description: >
        Lux threshold at which lights will turn off even with presence in the room (if Natural Light Auto-Off is enabled).
        When natural light sensor illuminance exceeds this value, the system assumes there's enough natural light 
        and turns off artificial lighting to save energy. Usually 70-150 lux.
      default: 100
      selector:
        number:
          min: 5
          max: 500
          unit_of_measurement: lux
          mode: slider
          step: 1
    sensor_affected_by_lights:
      name: Illuminance Sensor Affected By Lights
      description: >
        Choose whether your main illuminance sensor readings are affected by the artificial lights.
        Select YES if your sensor readings increase when your lights turn on.
        Select NO if your sensor only measures natural light (e.g., positioned to only 
        detect outside light or shielded from artificial lighting).
      default: false
      selector:
        boolean:
    sensor_off_latency_input:
      name: Sensor Off Latency Entity (Optional)
      description: >
        Entity that provides the sensor's off latency/timeout value in seconds (e.g., an input_number or sensor attribute).
        For Everything Presence devices, use number.everything_presence_xxx_occupancy_off_latency.
        Leave blank to use the 'Fixed Off Latency' value below.
        This is only needed if you want to dynamically adjust latency from another UI.
      selector:
        entity:
          domain: number
          multiple: false
      default: {} # Allows this input to be truly optional
    fixed_latency_seconds:
      name: Fixed Off Latency (seconds)
      description: >
        Fixed off latency value in seconds, used if 'Sensor Off Latency Entity' is not provided or unavailable.
        This is how long the sensor waits after the last detected motion before reporting "no presence".
        A higher value means the sensor is less responsive but reduces false negatives.
        Typically 30-120 seconds is appropriate, with 60 being a good default.
      default: 60
      selector:
        number:
          min: 10
          max: 300
          unit_of_measurement: sec
          mode: slider
          step: 10
    vacancy_timeout_multiplier:
      name: Vacancy Timeout Multiplier
      description: >
        Multiplier applied to the sensor off latency to determine when a room is considered truly vacant.
        The calculation is: vacancy_timeout_minutes = sensor_off_latency_seconds × multiplier ÷ 60.
        For example, with a 60s off latency and 5× multiplier, the room must be vacant for 5 minutes
        before lights turn off automatically or manual overrides are cleared. Higher values prevent
        false offs but delay automatic actions.
      default: 5
      selector:
        number:
          min: 1
          max: 30
          mode: slider
          step: 1
    override_timeout_hours:
      name: Override Timeout Hours
      description: >
        Maximum number of hours a manual override will remain active before being automatically cleared.
        This ensures that forgotten manual overrides don't permanently disable automation.
        After this time period, automation will resume normal operation even if manual override was set.
        Typical values are 2-4 hours for most rooms.
      default: 2
      selector:
        number:
          min: 1
          max: 24
          unit_of_measurement: hours
          mode: slider
          step: 0.5
    enable_debug_logs:
      name: Enable Debug Logs
      description: >
        Enable detailed debug logging in Home Assistant. These logs can help understand
        the automation's decision process, troubleshoot issues, and fine-tune settings.
        You can view logs in Configuration → Logs, filtered for your room name.
        Recommended to enable during initial setup and disable once everything works.
      default: false
      selector:
        boolean:

# Automation definition
variables:
  room_name: !input room_name
  presence_pir_sensor: !input presence_pir_sensor
  _presence_mmwave_sensor_input: !input presence_mmwave_sensor # Store raw input
  illuminance_sensor: !input illuminance_sensor
  _natural_light_sensor_input: !input natural_light_sensor # Store raw input
  light_switch: !input light_switch
  automation_active_helper: !input automation_active_helper
  manual_override_helper: !input manual_override_helper
  light_auto_on_helper: !input light_auto_on_helper
  last_automation_action_helper: !input last_automation_action_helper
  dark_threshold: !input dark_threshold
  bright_threshold: !input bright_threshold
  extremely_dark_threshold: !input extremely_dark_threshold
  auto_off_with_natural_light: !input auto_off_with_natural_light
  natural_light_high_threshold: !input natural_light_high_threshold
  sensor_affected_by_lights: !input sensor_affected_by_lights
  override_timeout_hours: !input override_timeout_hours
  enable_debug_logs: !input enable_debug_logs
  _sensor_off_latency_entity_input: !input sensor_off_latency_input # Store raw input
  fixed_latency_seconds: !input fixed_latency_seconds
  vacancy_timeout_multiplier: !input vacancy_timeout_multiplier

  # Derived variables with checks for optional inputs
  presence_mmwave_sensor_defined: "{{ _presence_mmwave_sensor_input is not none and _presence_mmwave_sensor_input != '' }}"
  natural_light_sensor_defined: "{{ _natural_light_sensor_input is not none and _natural_light_sensor_input != '' }}"
  sensor_off_latency_entity_defined: "{{ _sensor_off_latency_entity_input is not none and _sensor_off_latency_entity_input != '' }}"

  sensor_off_latency_seconds: >-
    {% if sensor_off_latency_entity_defined and states(_sensor_off_latency_entity_input) not in ['unknown', 'unavailable'] %}
      {{ states(_sensor_off_latency_entity_input) | float(fixed_latency_seconds) }}
    {% else %}
      {{ fixed_latency_seconds }}
    {% endif %}
  vacancy_timeout_minutes: >-
    {{ ([((sensor_off_latency_seconds * vacancy_timeout_multiplier) / 60) | round(0, 'ceil'), 1] | max) | int(5) }}
  illuminance: "{{ states(illuminance_sensor)|float(0) }}"
  
  natural_light_available: "{{ natural_light_sensor_defined }}" # Simplified, relies on natural_light_sensor_defined
  natural_light_level: >-
    {% if natural_light_available %}
      {{ states(_natural_light_sensor_input)|float(0) }}
    {% else %}
      0
    {% endif %}
  
  is_dark: "{{ illuminance < dark_threshold }}"
  is_bright: "{{ illuminance > bright_threshold }}"
  is_extremely_dark: "{{ illuminance < extremely_dark_threshold }}"
  is_naturally_bright: >-
    {% if natural_light_available %}
      {{ natural_light_level > natural_light_high_threshold }}
    {% else %}
      false
    {% endif %}
  
  pir_active: "{{ is_state(presence_pir_sensor, 'on') }}"
  mmwave_active: "{{ presence_mmwave_sensor_defined and is_state(_presence_mmwave_sensor_input, 'on') }}"
  someone_present: "{{ pir_active or mmwave_active }}"
  
  vacant_for_timeout: |-
    {% set pir_last_changed_seconds = (now() - states[presence_pir_sensor].last_changed).total_seconds() %}
    {% set pir_vacant = pir_last_changed_seconds > (vacancy_timeout_minutes * 60) %}
    {% if presence_mmwave_sensor_defined %}
      {% set mmwave_last_changed_seconds = (now() - states[_presence_mmwave_sensor_input].last_changed).total_seconds() %}
      {% set mmwave_vacant = mmwave_last_changed_seconds > (vacancy_timeout_minutes * 60) %}
      {{ not someone_present and pir_vacant and mmwave_vacant }}
    {% else %}
      {{ not someone_present and pir_vacant }}
    {% endif %}

  lights_on: "{{ is_state(light_switch, 'on') }}"
  user_toggled_lights: "{{ trigger.platform == 'state' and trigger.entity_id == light_switch }}"
  user_turned_on: "{{ user_toggled_lights and trigger.to_state.state == 'on' }}"
  user_turned_off: "{{ user_toggled_lights and trigger.to_state.state == 'off' }}"
  manual_override: "{{ is_state(manual_override_helper, 'on') }}"
  automation_inactive: "{{ is_state(automation_active_helper, 'off') }}"
  in_middle_range: "{{ not is_dark and not is_bright }}"
  hourly_check: "{{ trigger.platform == 'time_pattern' }}"
  override_timeout: |-
    {{ hourly_check and is_state(manual_override_helper, 'on') and
      (now() - states[manual_override_helper].last_changed).total_seconds() > (override_timeout_hours * 3600) }}
  sun_state: "{{ states('sun.sun') }}"
  is_daytime: "{{ sun_state == 'above_horizon' }}"
  is_nighttime: "{{ sun_state == 'below_horizon' }}"
  light_change_time: "{{ (now() - states[light_switch].last_changed).total_seconds() }}"
  light_recently_changed: "{{ light_change_time < 10 }}" # Consider making this threshold configurable
  
  time_since_last_automation: >-
    {% if states(last_automation_action_helper) != 'unknown' and
    states(last_automation_action_helper) != '' %}
      {% set timestamp_str = states(last_automation_action_helper).split('+')[0] %}
      {% set last_action_time = strptime(timestamp_str, '%Y-%m-%dT%H:%M:%S.%f', default=now().replace(tzinfo=None) - timedelta(seconds=99999)) %}
      {{ (now().replace(tzinfo=None) - last_action_time).total_seconds() }}
    {% else %}
      99999
    {% endif %}
  automation_initiated_change: >-
    {% set tsla = time_since_last_automation %}
    {{ tsla < 3.0 and tsla >= 0 }} # Ensure tsla is not negative from default strptime

  turn_off_due_to_natural_light: >-
    {% if auto_off_with_natural_light and natural_light_available %}
      {% if not sensor_affected_by_lights or natural_light_available %} {# This condition might need review: `or natural_light_available` seems redundant if already checked #}
        {{ lights_on and someone_present and is_naturally_bright and is_state(light_auto_on_helper, 'on') }}
      {% else %}
        false
      {% endif %}
    {% else %}
      false
    {% endif %}
  auto_would_turn_on_intent: "{{ (is_dark or is_extremely_dark) and someone_present }}"
  auto_would_turn_off_intent: "{{ not someone_present }}"
  auto_would_preserve_state_intent: >-
    {{ (in_middle_range and someone_present) or (is_bright and someone_present and not auto_off_with_natural_light) }}


trigger:
  - platform: state
    entity_id:
      - !input presence_pir_sensor
      - !input illuminance_sensor
      - !input light_switch
      - sun.sun
      # Optional sensors removed from direct trigger to prevent error if not configured:
      # - !input presence_mmwave_sensor 
      # - !input natural_light_sensor
      # - !input sensor_off_latency_input 
      # Their states will be evaluated when the automation runs due to other triggers.
  - platform: time_pattern # For hourly override check
    hours: /1

action:
  - if:
      - condition: template
        value_template: "{{ enable_debug_logs }}"
    then:
      - service: system_log.write
        data:
          level: info
          message: >-
            ==================== {{ room_name | upper }} AUTOMATION TRIGGERED ====================
            Trigger Platform: {{ trigger.platform }}, Trigger Entity: {{ trigger.entity_id }}
            Illuminance: {{ illuminance }} lx (Dark: {{ is_dark }}, XDark: {{ is_extremely_dark }}, Bright: {{ is_bright }})
            Presence: {{ someone_present }} (PIR: {{ pir_active }}, mmWave: {{ mmwave_active }})
            Lights: {{ 'ON' if lights_on else 'OFF' }}, Manual Override: {{ manual_override }}
            Light Auto On: {{ is_state(light_auto_on_helper, 'on') }}
            Vacancy Timeout: {{ vacancy_timeout_minutes }} min (Latency: {{ sensor_off_latency_seconds }}s)
            Last Automation: {{ states(last_automation_action_helper) }} ({{ time_since_last_automation | round(1) }}s ago)
            Automation Initiated Change: {{ automation_initiated_change }}
            Natural Light: {{ 'Available' if natural_light_available else 'N/A' }} (Level: {{ natural_light_level }} lx, Is Bright: {{ is_naturally_bright }})
            Turn Off Due to Natural: {{ turn_off_due_to_natural_light }}

  # Handle manual user actions first
  - choose:
      - conditions:
          - condition: template # User toggled lights and it wasn't the automation itself
            value_template: "{{ user_toggled_lights and not automation_initiated_change }}"
        sequence:
          - if: # Debug log for manual action
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: >-
                    {{ room_name | upper }} MANUAL ACTION: User toggled lights {{ 'ON' if user_turned_on else 'OFF' }}.
                    Intent: Auto ON: {{ auto_would_turn_on_intent }}, Auto OFF: {{ auto_would_turn_off_intent }}, Preserve: {{ auto_would_preserve_state_intent }}
                    Bright Room: {{ is_bright }}, Present: {{ someone_present }}
          
          # Set manual override ON initially for any distinct user action
          - service: input_boolean.turn_on
            target:
              entity_id: "{{ manual_override_helper }}"
          - delay: # Short delay to ensure helper state updates before next check
              milliseconds: 50 
          
          # Logic to determine if this manual action should clear or keep the override
          - choose:
              # Condition 1: User turned OFF lights in a BRIGHT room while someone is present (and automation is inactive)
              # This clears the override because the user is essentially saying "it's bright enough, lights off".
              - conditions:
                  - "{{ user_turned_off and is_bright and someone_present and automation_inactive }}"
                  - "{{ (now() - states[automation_active_helper].last_changed).total_seconds() > 2.0 }}" # Ensure automation wasn't just active
                sequence:
                  - service: input_boolean.turn_off # Clear manual override
                    target:
                      entity_id: "{{ manual_override_helper }}"
                  - service: input_boolean.turn_off # Light was not auto turned on
                    target:
                      entity_id: "{{ light_auto_on_helper }}"
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: "{{ room_name | upper }} OVERRIDE CLEARED: User turned OFF lights in bright, occupied room."
              
              # Condition 2: User's action aligns with what automation would have done. Clear override.
              - conditions:
                  - >-
                    {{ (user_turned_on and auto_would_turn_on_intent) or
                       (user_turned_off and auto_would_turn_off_intent) }}
                  - "{{ automation_inactive }}"
                  - "{{ (now() - states[automation_active_helper].last_changed).total_seconds() > 2.0 }}"
                sequence:
                  - service: input_boolean.turn_off # Clear manual override
                    target:
                      entity_id: "{{ manual_override_helper }}"
                  # If user turned on, and automation would have, mark as auto_on if it wasn't already
                  - if: "{{ user_turned_on and auto_would_turn_on_intent and not is_state(light_auto_on_helper, 'on') }}"
                    then:
                      - service: input_boolean.turn_on
                        target:
                          entity_id: "{{ light_auto_on_helper }}"
                  - else: # User turned off, or user turned on but it was already auto_on
                      - service: input_boolean.turn_off
                        target:
                          entity_id: "{{ light_auto_on_helper }}"
                  - if:
                      - condition: template
                        value_template: "{{ enable_debug_logs }}"
                    then:
                      - service: system_log.write
                        data:
                          level: info
                          message: "{{ room_name | upper }} OVERRIDE CLEARED: User action aligns with automation intent."
              
              # Condition 3: User's action conflicts with automation intent. Override remains ON.
              # (This is the default if above conditions are not met, because override was set ON initially)
              default:
                - service: input_boolean.turn_off # Light was not auto turned on by this user action
                  target:
                    entity_id: "{{ light_auto_on_helper }}"
                - if:
                    - condition: template
                      value_template: "{{ enable_debug_logs }}"
                  then:
                    - service: system_log.write
                      data:
                        level: info
                        message: "{{ room_name | upper }} OVERRIDE ACTIVE: User action conflicts with automation intent."
          - delay: # Short delay for helper state to be logged correctly if debug is on
              milliseconds: 50
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: >-
                    {{ room_name | upper }} AFTER USER TOGGLE: Manual Override: {{ is_state(manual_override_helper, 'on') }}, 
                    Light Auto On: {{ is_state(light_auto_on_helper, 'on') }}

  # Main automation logic - only proceed if not a user toggle that was just handled
  - choose:
      # Skip actions if manual override is active (unless it's a timeout condition for the override itself)
      - conditions:
          - "{{ manual_override }}"
          - "{{ not (user_toggled_lights and not automation_initiated_change) }}" # Not a fresh user toggle
          - "{{ not override_timeout }}" # Not an hourly override timeout
          - "{{ not vacant_for_timeout }}" # Not a vacancy override timeout
        sequence:
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "{{ room_name | upper }} SKIPPING AUTO-ACTIONS: Manual override active."

      # Clear override after vacancy timeout
      - conditions:
          - "{{ vacant_for_timeout }}"
          - "{{ manual_override }}" # Only if override is currently active
        sequence:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ manual_override_helper }}"
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ light_auto_on_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "{{ room_name | upper }} OVERRIDE CLEARED: Vacancy timeout ({{ vacancy_timeout_minutes }}m)."
          - delay: # Allow helpers to update
              milliseconds: 100
          - service: automation.trigger # Re-evaluate state now that override is cleared
            target:
              entity_id: "{{this.entity_id}}"
            data:
              skip_condition: true

      # Clear override after hourly timeout
      - conditions:
          - "{{ override_timeout }}" # This implies manual_override is on
        sequence:
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ manual_override_helper }}"
          - service: input_boolean.turn_off
            target:
              entity_id: "{{ light_auto_on_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "{{ room_name | upper }} OVERRIDE CLEARED: Hourly timeout ({{ override_timeout_hours }}h)."
          - delay: # Allow helpers to update
              milliseconds: 100
          - service: automation.trigger # Re-evaluate state now that override is cleared
            target:
              entity_id: "{{this.entity_id}}"
            data:
              skip_condition: true
      
      # Turn OFF lights due to sufficient natural light (if enabled and no override)
      - conditions:
          - "{{ turn_off_due_to_natural_light }}"
          - "{{ not manual_override }}"
        sequence:
          - service: input_boolean.turn_on # Mark automation as active
            target:
              entity_id: "{{ automation_active_helper }}"
          - service: input_text.set_value # Record action time
            target:
              entity_id: "{{ last_automation_action_helper }}"
            data:
              value: "{{ now().isoformat() }}"
          - choose:
              - conditions: "{{ light_switch.startswith('light.') }}"
                sequence:
                  - service: light.turn_off
                    target:
                      entity_id: "{{ light_switch }}"
              default:
                - service: switch.turn_off
                  target:
                    entity_id: "{{ light_switch }}"
          - service: input_boolean.turn_off # Light is no longer "auto on"
            target:
              entity_id: "{{ light_auto_on_helper }}"
          - delay: # Allow light to turn off and state to propagate
              milliseconds: 1500 
          - service: input_boolean.turn_off # Mark automation as inactive
            target:
              entity_id: "{{ automation_active_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "{{ room_name | upper }} AUTO LIGHTS OFF: Sufficient natural light."

      # Automatically turn ON lights (dark, present, lights off, no override, not recently changed)
      - conditions:
          - "{{ is_dark or is_extremely_dark }}"
          - "{{ someone_present }}"
          - "{{ not lights_on }}"
          - "{{ not manual_override }}"
          - "{{ not light_recently_changed }}" # Avoids fighting with quick manual toggles
        sequence:
          - service: input_boolean.turn_on # Mark automation as active
            target:
              entity_id: "{{ automation_active_helper }}"
          - service: input_text.set_value # Record action time
            target:
              entity_id: "{{ last_automation_action_helper }}"
            data:
              value: "{{ now().isoformat() }}"
          - choose:
              - conditions: "{{ light_switch.startswith('light.') }}"
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ light_switch }}"
              default:
                - service: switch.turn_on
                  target:
                    entity_id: "{{ light_switch }}"
          - service: input_boolean.turn_on # Mark light as auto turned on
            target:
              entity_id: "{{ light_auto_on_helper }}"
          - delay: # Allow light to turn on and state to propagate
              milliseconds: 1500
          - service: input_boolean.turn_off # Mark automation as inactive
            target:
              entity_id: "{{ automation_active_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "{{ room_name | upper }} AUTO LIGHTS ON: Dark/XDark and Occupied."

      # Automatically turn OFF lights (vacant, lights on, no override)
      # This is for immediate vacancy, not the vacancy timeout for override clearing
      - conditions:
          - "{{ not someone_present }}" # Immediate vacancy based on sensor states
          - "{{ lights_on }}"
          - "{{ not manual_override }}"
          - "{{ is_state(light_auto_on_helper, 'on') }}" # Only turn off if automation turned it on
        sequence:
          - service: input_boolean.turn_on # Mark automation as active
            target:
              entity_id: "{{ automation_active_helper }}"
          - service: input_text.set_value # Record action time
            target:
              entity_id: "{{ last_automation_action_helper }}"
            data:
              value: "{{ now().isoformat() }}"
          - choose:
              - conditions: "{{ light_switch.startswith('light.') }}"
                sequence:
                  - service: light.turn_off
                    target:
                      entity_id: "{{ light_switch }}"
              default:
                - service: switch.turn_off
                  target:
                    entity_id: "{{ light_switch }}"
          - service: input_boolean.turn_off # Light is no longer "auto on"
            target:
              entity_id: "{{ light_auto_on_helper }}"
          - delay: # Allow light to turn off and state to propagate
              milliseconds: 1500
          - service: input_boolean.turn_off # Mark automation as inactive
            target:
              entity_id: "{{ automation_active_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_debug_logs }}"
            then:
              - service: system_log.write
                data:
                  level: info
                  message: "{{ room_name | upper }} AUTO LIGHTS OFF: Vacant (and light was auto_on)."
      
      # Default: No specific auto action conditions met
      default:
        - if:
            - condition: template
              value_template: "{{ enable_debug_logs }}"
          then:
            - service: system_log.write
              data:
                level: info
                message: "{{ room_name | upper }} NO AUTO ACTION: Conditions not met or override active. Current state preserved."

  # Final state logging
  - if:
      - condition: template
        value_template: "{{ enable_debug_logs }}"
    then:
      - service: system_log.write
        data:
          level: info
          message: >-
            {{ room_name | upper }} FINAL HELPER STATES: Manual Override: {{ is_state(manual_override_helper, 'on') }}, 
            Automation Active: {{ is_state(automation_active_helper, 'on') }}, 
            Light Auto On: {{ is_state(light_auto_on_helper, 'on') }}, 
            Lights Actual State: {{ 'ON' if is_state(light_switch, 'on') else 'OFF' }}
      - service: system_log.write
        data:
          level: info
          message: >-
            ==================== {{ room_name | upper }} AUTOMATION COMPLETE ====================

mode: queued
max: 10 # Max number of runs to queue if automation is already running
max_exceeded: silent # What to do if max is exceeded
